<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="pt"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Lcom4Listener.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jqana</a> &gt; <a href="index.source.html" class="el_package">com.obomprogramador.tools.jqana.parsers</a> &gt; <span class="el_source">Lcom4Listener.java</span></div><h1>Lcom4Listener.java</h1><pre class="source lang-java linenums">/**
 * jQana - Open Source Java(TM) code quality analyzer.
 * 
 * Copyright 2013 Cleuton Sampaio de Melo Jr
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * 
 * Project website: http://www.jqana.com
 */
package com.obomprogramador.tools.jqana.parsers;

import java.util.Arrays;
import java.util.List;

import org.antlr.v4.runtime.misc.NotNull;
import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.ParseTreeWalker;
import org.antlr.v4.runtime.tree.TerminalNodeImpl;
import org.apache.commons.lang.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.obomprogramador.tools.jqana.antlrparser.JavaBaseListener;
import com.obomprogramador.tools.jqana.antlrparser.JavaParser;
import com.obomprogramador.tools.jqana.antlrparser.JavaParser.AnnotationContext;
import com.obomprogramador.tools.jqana.antlrparser.JavaParser.ClassDeclarationContext;
import com.obomprogramador.tools.jqana.antlrparser.JavaParser.CompilationUnitContext;
import com.obomprogramador.tools.jqana.antlrparser.JavaParser.ExpressionContext;
import com.obomprogramador.tools.jqana.antlrparser.JavaParser.FieldDeclarationContext;
import com.obomprogramador.tools.jqana.antlrparser.JavaParser.FormalParametersContext;
import com.obomprogramador.tools.jqana.antlrparser.JavaParser.MethodBodyContext;
import com.obomprogramador.tools.jqana.antlrparser.JavaParser.MethodDeclarationContext;
import com.obomprogramador.tools.jqana.antlrparser.JavaParser.PackageDeclarationContext;
import com.obomprogramador.tools.jqana.antlrparser.JavaParser.VariableDeclaratorContext;
import com.obomprogramador.tools.jqana.antlrparser.JavaParser.VariableDeclaratorIdContext;
import com.obomprogramador.tools.jqana.antlrparser.JavaParser.VariableDeclaratorsContext;
import com.obomprogramador.tools.jqana.model.defaultimpl.GetClassNameFromContext;
import com.obomprogramador.tools.jqana.parsers.Member.MEMBER_TYPE;

/**
 * Implementation of JavaBaseListener (ANTLR4) that checks LCOM4 value for a
 * class.
 * 
 * How does it work? It creates a class' members array, containing each method
 * or variable. For each method, the listener verifies any of its references,
 * for example: referenced methods and variables, and so on. This array is
 * returned to the parser, that calculated LCOM4.
 * 
 * It classifies each class member according to its MEMBER_TYPE.
 * 
 * @see GobalConstants.MEMBER_TYPE
 * 
 * 
 * @author Cleuton Sampaio.
 * 
 */
public class Lcom4Listener extends JavaBaseListener {

    protected Logger logger;
    protected List&lt;Member&gt; membersTable;
    protected JavaParser parser;
<span class="fc" id="L72">    protected String[] prefixos = {&quot;get&quot;, &quot;set&quot;, &quot;is&quot;, &quot;has&quot;};</span>
<span class="fc" id="L73">    protected List&lt;String&gt; getterSetterPrefix = Arrays.asList(prefixos);</span>
    protected String mainPackageName;
    protected String mainClassName;
    protected boolean alreadyGotMainClass;
    protected boolean overrideAnnotation;
    private static final int PACKAGE_DISPLACEMENT = 7;
    
    /**
     * Getter for MainClass name.
     * @return String main class name.
     */
    public String getMainClassName() {
<span class="fc" id="L85">        return mainClassName;</span>
    }

    /**
     * Setter for main class name.
     * @param mainClassName String main class name.
     */
    public void setMainClassName(String mainClassName) {
<span class="nc" id="L93">        this.mainClassName = mainClassName;</span>
<span class="nc" id="L94">    }</span>

    /**
     * Constructor with fields.
     * @param members List&lt;member&gt; list of class' members.
     * @param p JavaParser the java parser being used.
     */
<span class="fc" id="L101">    public Lcom4Listener(List&lt;Member&gt; members, JavaParser p) {</span>
<span class="fc" id="L102">        this.logger = LoggerFactory.getLogger(this.getClass());</span>
<span class="fc" id="L103">        this.membersTable = members;</span>
<span class="fc" id="L104">        this.parser = p;</span>
<span class="fc" id="L105">    }</span>

    @Override
    public void enterClassDeclaration(@NotNull ClassDeclarationContext ctx) {
<span class="fc bfc" id="L109" title="All 2 branches covered.">        if (!alreadyGotMainClass) {</span>
<span class="fc" id="L110">            mainClassName = GetClassNameFromContext.getClassName(ctx);</span>
<span class="fc" id="L111">            alreadyGotMainClass = true;</span>
        }

<span class="fc" id="L114">    }</span>

    @Override
    public void enterPackageDeclaration(@NotNull PackageDeclarationContext ctx) {
<span class="fc" id="L118">        mainPackageName = ctx.getText().substring(PACKAGE_DISPLACEMENT);</span>
<span class="fc" id="L119">        logger.debug(mainPackageName);</span>
<span class="fc" id="L120">    }</span>

    /**
     * Get the field's name, which is a tricky task.
     * @param ctx Context the context in use.
     */
    @Override
    public void enterFieldDeclaration(@NotNull FieldDeclarationContext ctx) {
<span class="fc" id="L128">        String name = &quot;&quot;;</span>

<span class="pc bpc" id="L130" title="1 of 2 branches missed.">        for (ParseTree subTree : ctx.children) {</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">            if (subTree instanceof VariableDeclaratorsContext) {</span>
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">                for (ParseTree st2 : ((VariableDeclaratorsContext) subTree).children) {</span>
<span class="pc bpc" id="L133" title="1 of 2 branches missed.">                    if (st2 instanceof VariableDeclaratorContext) {</span>
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">                        for (ParseTree st3 : ((VariableDeclaratorContext) st2).children) {</span>
<span class="pc bpc" id="L135" title="1 of 2 branches missed.">                            if (st3 instanceof VariableDeclaratorIdContext) {</span>
<span class="fc" id="L136">                                name = st3.getText();</span>
<span class="fc" id="L137">                                break;</span>
                            }
<span class="nc" id="L139">                        }</span>
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">                        if (name.length() &gt; 0) {</span>
<span class="fc" id="L141">                            break;</span>
                        }
                    }
<span class="nc bnc" id="L144" title="All 2 branches missed.">                    if (name.length() &gt; 0) {</span>
<span class="nc" id="L145">                        break;</span>
                    }
<span class="nc" id="L147">                }</span>
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">                if (name.length() &gt; 0) {</span>
<span class="fc" id="L149">                    break;</span>
                }
            }
<span class="fc" id="L152">        }</span>
<span class="fc" id="L153">        Member member = new Member();</span>
<span class="fc" id="L154">        member.className = mainClassName;</span>
<span class="fc" id="L155">        member.name = name;</span>
<span class="fc" id="L156">        member.packageName = this.mainPackageName;</span>
<span class="fc" id="L157">        member.type = MEMBER_TYPE.VARIABLE;</span>
<span class="fc" id="L158">        this.membersTable.add(member);</span>
<span class="fc" id="L159">    }</span>

    @Override
    public void enterAnnotation(@NotNull AnnotationContext ctx) {
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">        if (ctx.getText().equals(&quot;@Override&quot;)) {</span>
<span class="fc" id="L164">            this.overrideAnnotation = true;</span>
        }
<span class="fc" id="L166">    }</span>

    /**
     * We add each method to the members array. Then we will check for
     * references.
     * @param ctx Context the context in use.
     */
    @Override
    public void enterMethodDeclaration(@NotNull MethodDeclarationContext ctx) {
<span class="fc" id="L175">        String methodName = &quot;&lt;no name&gt;&quot;;</span>
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">        for (ParseTree subTree : ctx.children) {</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">            if (subTree instanceof TerminalNodeImpl) {</span>
<span class="fc" id="L178">                methodName = subTree.toString();</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">            } else if (subTree instanceof FormalParametersContext) {</span>
<span class="fc" id="L180">                break;</span>
            }
<span class="fc" id="L182">        }</span>

<span class="fc" id="L184">        ParseTree body = null;</span>
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">        for (ParseTree subTree : ctx.children) {</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">            if (subTree instanceof MethodBodyContext) {</span>
<span class="fc" id="L187">                body = subTree;</span>
<span class="fc" id="L188">                break;</span>
            }
<span class="fc" id="L190">        }</span>

<span class="fc bfc" id="L192" title="All 2 branches covered.">        if (this.overrideAnnotation) {</span>
<span class="fc" id="L193">            logger.debug(&quot;*** Inherited method ignored: &quot; + methodName);</span>
        } else {
<span class="fc" id="L195">            logger.debug(&quot;- Method found: &quot; + methodName);</span>
<span class="fc" id="L196">            Member member = new Member();</span>
<span class="fc" id="L197">            member.className = mainClassName;</span>
<span class="fc" id="L198">            member.name = methodName;</span>
<span class="fc" id="L199">            member.packageName = this.mainPackageName;</span>
<span class="fc" id="L200">            member.type = MEMBER_TYPE.METHOD;</span>
<span class="fc" id="L201">            member.body = body;</span>
<span class="fc" id="L202">            this.membersTable.add(member);</span>
        }

<span class="fc" id="L205">        this.overrideAnnotation = false;</span>
<span class="fc" id="L206">    }</span>

    /**
     * This is a special inner listener, used to check for a method's
     * references.
     * 
     * @author Cleuton Sampaio
     * 
     */
    class Lcom4MethodListener extends JavaBaseListener {
        private Member member;

<span class="fc" id="L218">        public Lcom4MethodListener(Member member) {</span>
<span class="fc" id="L219">            this.member = member;</span>
<span class="fc" id="L220">        }</span>

        /**
         * We have to check any expression, looking for other methods and
         * variables references.
         */
        @Override
        public void enterExpression(@NotNull ExpressionContext ctx) {
<span class="fc bfc" id="L228" title="All 2 branches covered.">            if (ctx.children.size() == 1) {</span>
<span class="fc" id="L229">                String exprMember = ctx.getText();</span>
<span class="fc" id="L230">                logger.debug(&quot;Expression Member: &quot; + exprMember);</span>
<span class="fc" id="L231">                Member nMember = new Member();</span>
<span class="fc" id="L232">                member.className = mainClassName;</span>
<span class="fc" id="L233">                member.packageName = mainPackageName;</span>
<span class="fc" id="L234">                nMember.name = exprMember;</span>
<span class="fc bfc" id="L235" title="All 2 branches covered.">                if (membersTable.contains(nMember)) {</span>
<span class="pc bpc" id="L236" title="1 of 2 branches missed.">                    if (!member.referencedMembers.contains(exprMember)) {</span>
<span class="fc" id="L237">                        int indx = membersTable.indexOf(nMember);</span>
<span class="fc" id="L238">                        nMember = membersTable.get(indx);</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">                        if (nMember.type == MEMBER_TYPE.GETTER_SETTER) {</span>
<span class="fc" id="L240">                            member.referencedMembers</span>
                                    .add(nMember.targetVariable);
                        } else {
<span class="fc" id="L243">                            member.referencedMembers.add(nMember);</span>
                        }
<span class="fc" id="L245">                        logger.debug(&quot;Class Member reference added: &quot;</span>
                                + exprMember);
                    }
                }
            }
<span class="fc" id="L250">        }</span>

    }

    /**
     * Now, that we finished analysing the class, we need to verify each found
     * method's referencies. So, we instantiate our special listener and walk
     * each method's tree.
     * 
     * @param ctx Context the context to use.
     */
    @Override
    public void exitCompilationUnit(@NotNull CompilationUnitContext ctx) {

<span class="fc bfc" id="L264" title="All 2 branches covered.">        for (Member m : this.membersTable) {</span>
<span class="fc" id="L265">            ParseTreeWalker walker = new ParseTreeWalker();</span>
<span class="fc bfc" id="L266" title="All 2 branches covered.">            if (m.type == MEMBER_TYPE.METHOD) {</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">                if (checkForGetterSetter(m)) {</span>
<span class="fc" id="L268">                    m.type = MEMBER_TYPE.GETTER_SETTER;</span>
                } else {
<span class="fc" id="L270">                    Lcom4MethodListener ml = new Lcom4MethodListener(m);</span>
<span class="fc" id="L271">                    walker.walk(ml, m.body);</span>
                }
            }
<span class="fc" id="L274">        }</span>

<span class="fc" id="L276">        System.out.println(&quot;FIM&quot;);</span>
<span class="fc" id="L277">    }</span>

    private boolean checkForGetterSetter(Member m) {
<span class="fc" id="L280">        boolean isGetterSetter = false;</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">        for (Member n : this.membersTable) {</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">            if (n.type == MEMBER_TYPE.VARIABLE) {</span>
<span class="fc bfc" id="L283" title="All 2 branches covered.">                if (StringUtils.containsIgnoreCase(m.name, n.name)) {</span>
                    // StringUtils.strip(&quot;  abcyx&quot;, &quot;xyz&quot;) = &quot;  abc&quot;
<span class="fc" id="L285">                    String beginMethodName = StringUtils.stripEnd(</span>
                            m.name.toLowerCase(), n.name.toLowerCase());
<span class="fc bfc" id="L287" title="All 2 branches covered.">                    if (this.getterSetterPrefix.contains(beginMethodName)) {</span>
<span class="fc" id="L288">                        isGetterSetter = true;</span>
<span class="fc" id="L289">                        m.targetVariable = n;</span>
                    }
                    break;
                }
            }
<span class="fc" id="L294">        }</span>
<span class="fc" id="L295">        return isGetterSetter;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312101107</span></div></body></html>